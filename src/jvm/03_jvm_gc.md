---
title: JVM的垃圾回收
icon: fab fa-markdown
order: 3
category:
  - Java
tag:
  - jvm
editLink: false
---

## 前言
垃圾的定义： 不再被引用的对象就是垃圾。  
那如何判断一个对象是否被引用呢？
- 引用计数法  用一个标记记录引用次数，当引用次数为0时，就是垃圾
- 可达性分析法  从GC Roots开始，遍历所有对象，如果对象不可达，就是垃圾。

## 垃圾回收算法
- 标记-清除算法  
先标记好回收的对象，然后统一回收
- 标记-压缩算法  
标记好回收的对象，然后将存活的对象压缩到一端，然后回收另一端的空间
- 复制算法  
将内存分为两块，每次只使用一块，当这一块满了，就将存活的对象复制到另一块，然后回收这一块
- 分代算法  
根据对象的存活周期将内存分为不同的区域，然后根据不同的区域使用不同的算法


## 垃圾回收器

垃圾回收器是实现垃圾回收算法的具体实现，根据不同的算法和实现，可以分为以下几种
先看一张图，了解一下各个垃圾回收器的关系  

![](https://www.luoliang.top/images/jvm_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%9F.png)


### Serial收集器
在新生代使用复制算法，在老年代使用标记-清除算法
- 使用单线程进行回收

优点：简单高效，没有线程切换的开销  
缺点：无法充分利用多核CPU

### ParNew收集器
使用复制算法，多线程进行回收，可以和CMS收集器配合使用

### Parallel Scavenge收集器
使用复制算法，多线程进行回收


### Serial Old收集器
用于老年代的收集器，使用标记-清除算法

### Parallel Old收集器

### CMS收集器
CMS(Concurrent Mark Sweep)收集器，是一种以获取最短回收停顿时间为目标的收集器.
使用标记-清除算法，分为以下几个阶段
- 初始标记 标记GC Roots能直接关联到的对象(STW)
- 并发标记 标记所有对象
- 重新标记 修正并发标记期间因用户程序继续运行导致标记产生变动的对象(STW)
- 并发清除 清除对象
- 并发清理 清理对象

![](https://www.luoliang.top/images/jvm_cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.jpeg)

### G1收集器
G1 (Garbage-First)收集器，最大的特点是可以设置期望停顿时间，然后在这个时间内尽可能多的进行垃圾回收。
不再区分新生代和老年代，而是将内存分为多个区域，每个区域都可以是新生代或者老年代。  

region的类型有以下几种:
- Eden        堆内存默认占比 5%
- Survivor    新生代存货区 
- Old         老年代区域
- Humongous  超过region50%大小的对象被确认为大对象，会被放到Humongous区域

#### 垃圾回收过程
- 初始标记 标记GC Roots能直接关联到的对象(STW)
- 并发标记 标记所有对象
- 最终标记 修正并发标记期间因用户程序继续运行导致标记产生变动的对象(STW)
- 筛选回收 选择回收对象

![](https://www.luoliang.top/images/jvm_g1_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png)



#### G1收集器的优点
- 并行与并发 G1在并行处理的同时，也能与应用程序并发执行，充分利用多核CPU
- 分代收集 G1不再区分新生代和老年代，而是将内存分为多个区域，每个区域都可以是新生代或者老年代
- 空间整合 G1收集器会进行空间整合，减少内存碎片
- 可预测的停顿 G1可以设置期望停顿时间，然后在这个时间内尽可能多的进行垃圾回收



### ZGC收集器

### Shenandoah收集器

