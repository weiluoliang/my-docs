import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as l,a as s}from"./app-F_h5rXgP.js";const t={},r=s(`<h2 id="类加载器分类" tabindex="-1"><a class="header-anchor" href="#类加载器分类"><span>类加载器分类</span></a></h2><h3 id="启动类加载器-bootstrapclassloader" tabindex="-1"><a class="header-anchor" href="#启动类加载器-bootstrapclassloader"><span>启动类加载器 BootstrapClassLoader</span></a></h3><p>负责加载核心包 如 rt.jar ,charsets.jar , 目录位于 JRE的lib下</p><h3 id="扩展类加载器-extclassloader" tabindex="-1"><a class="header-anchor" href="#扩展类加载器-extclassloader"><span>扩展类加载器 ExtClassloader</span></a></h3><p>负责加载JRE的扩展库，目录位于JRE的lib/ext 。</p><h3 id="应用类加载器-appclassloader" tabindex="-1"><a class="header-anchor" href="#应用类加载器-appclassloader"><span>应用类加载器 AppClassloader</span></a></h3><p>负责加载classpath下的类库， 可指定加载jar ，加参数 --classpath , --cp</p><h3 id="自定义类加载-customxxxclassloader" tabindex="-1"><a class="header-anchor" href="#自定义类加载-customxxxclassloader"><span>自定义类加载 CustomXxxClassloader</span></a></h3><h2 id="类加载过程" tabindex="-1"><a class="header-anchor" href="#类加载过程"><span>类加载过程</span></a></h2><h3 id="加载" tabindex="-1"><a class="header-anchor" href="#加载"><span>加载</span></a></h3><p>将字节码文件从硬盘读取到内存的过程，这个过程是按需加载，只有被使用到的类才会加载， <code>new</code> 一个对象 , <code>class.forName(&quot;xxx.class&quot;)</code> 等会触发加载 。</p><p>注意 ： <code>Math math = null</code> 这种不会被加载</p><h3 id="校验" tabindex="-1"><a class="header-anchor" href="#校验"><span>校验</span></a></h3><p>验证字节码文件格式是否正确</p><h3 id="准备" tabindex="-1"><a class="header-anchor" href="#准备"><span>准备</span></a></h3><p>给静态变量分配内存，并赋默认值。</p><h3 id="解析" tabindex="-1"><a class="header-anchor" href="#解析"><span>解析</span></a></h3><p>将符号引用替换为直接因为， <strong>静态链接过程</strong></p><h3 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h3><ol><li>给静态变量赋值</li><li>执行静态代码块</li></ol><blockquote><p>静态变量与静态代码块不区分优先级，按代码顺序执行</p></blockquote><h2 id="双亲委派机制" tabindex="-1"><a class="header-anchor" href="#双亲委派机制"><span>双亲委派机制</span></a></h2><h3 id="双亲委派机制的过程" tabindex="-1"><a class="header-anchor" href="#双亲委派机制的过程"><span>双亲委派机制的过程</span></a></h3><ol><li>委托父类加载器加载</li><li>父类加载器找不到再自己去加载</li></ol><blockquote><p>表现为向上委托，向下加载的过程</p></blockquote><h3 id="为什么需要双亲委派机制" tabindex="-1"><a class="header-anchor" href="#为什么需要双亲委派机制"><span>为什么需要双亲委派机制？</span></a></h3><ol><li>避免重复加载</li><li>防止核心类被篡改</li></ol><h3 id="tomcat打破双亲委派机制" tabindex="-1"><a class="header-anchor" href="#tomcat打破双亲委派机制"><span>Tomcat打破双亲委派机制</span></a></h3><p>一个Tomcat实例支持多个应用</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>tomcat
  -- webapp1  依赖spring 3 
  -- webapp2  依赖spring 4
  -- webapp3  依赖spring 5 

我们看到每个应用可能依赖不同的spring，如果使用双亲委派会导致版本问题，所以Tomcat必须打破双亲委派
  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="如何打破双亲委派机制" tabindex="-1"><a class="header-anchor" href="#如何打破双亲委派机制"><span>如何打破双亲委派机制？</span></a></h3><p>自己写一个类去继承 <code>ClassLoader</code> , 并且重写 <code>loadClass</code> 和 <code>findClass</code> 两个方法。</p>`,32),o=[r];function i(n,c){return a(),l("div",null,o)}const h=e(t,[["render",i],["__file","02_jvm_classloader.html.vue"]]),m=JSON.parse('{"path":"/jvm/02_jvm_classloader.html","title":"类加载子系统","lang":"zh-CN","frontmatter":{"title":"类加载子系统","icon":"fab fa-markdown","order":2,"category":["Java"],"tag":["jvm"],"editLink":false,"description":"类加载器分类 启动类加载器 BootstrapClassLoader 负责加载核心包 如 rt.jar ,charsets.jar , 目录位于 JRE的lib下 扩展类加载器 ExtClassloader 负责加载JRE的扩展库，目录位于JRE的lib/ext 。 应用类加载器 AppClassloader 负责加载classpath下的类库， 可指...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/jvm/02_jvm_classloader.html"}],["meta",{"property":"og:site_name","content":"luoliang的笔记"}],["meta",{"property":"og:title","content":"类加载子系统"}],["meta",{"property":"og:description","content":"类加载器分类 启动类加载器 BootstrapClassLoader 负责加载核心包 如 rt.jar ,charsets.jar , 目录位于 JRE的lib下 扩展类加载器 ExtClassloader 负责加载JRE的扩展库，目录位于JRE的lib/ext 。 应用类加载器 AppClassloader 负责加载classpath下的类库， 可指..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-11T15:27:56.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:modified_time","content":"2024-03-11T15:27:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"类加载子系统\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-11T15:27:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"类加载器分类","slug":"类加载器分类","link":"#类加载器分类","children":[{"level":3,"title":"启动类加载器 BootstrapClassLoader","slug":"启动类加载器-bootstrapclassloader","link":"#启动类加载器-bootstrapclassloader","children":[]},{"level":3,"title":"扩展类加载器 ExtClassloader","slug":"扩展类加载器-extclassloader","link":"#扩展类加载器-extclassloader","children":[]},{"level":3,"title":"应用类加载器 AppClassloader","slug":"应用类加载器-appclassloader","link":"#应用类加载器-appclassloader","children":[]},{"level":3,"title":"自定义类加载 CustomXxxClassloader","slug":"自定义类加载-customxxxclassloader","link":"#自定义类加载-customxxxclassloader","children":[]}]},{"level":2,"title":"类加载过程","slug":"类加载过程","link":"#类加载过程","children":[{"level":3,"title":"加载","slug":"加载","link":"#加载","children":[]},{"level":3,"title":"校验","slug":"校验","link":"#校验","children":[]},{"level":3,"title":"准备","slug":"准备","link":"#准备","children":[]},{"level":3,"title":"解析","slug":"解析","link":"#解析","children":[]},{"level":3,"title":"初始化","slug":"初始化","link":"#初始化","children":[]}]},{"level":2,"title":"双亲委派机制","slug":"双亲委派机制","link":"#双亲委派机制","children":[{"level":3,"title":"双亲委派机制的过程","slug":"双亲委派机制的过程","link":"#双亲委派机制的过程","children":[]},{"level":3,"title":"为什么需要双亲委派机制？","slug":"为什么需要双亲委派机制","link":"#为什么需要双亲委派机制","children":[]},{"level":3,"title":"Tomcat打破双亲委派机制","slug":"tomcat打破双亲委派机制","link":"#tomcat打破双亲委派机制","children":[]},{"level":3,"title":"如何打破双亲委派机制？","slug":"如何打破双亲委派机制","link":"#如何打破双亲委派机制","children":[]}]}],"git":{"createdTime":1710148641000,"updatedTime":1710170876000,"contributors":[{"name":"William","email":"wll@example.com","commits":1},{"name":"william","email":"625753396@qq.com","commits":1}]},"readingTime":{"minutes":1.53,"words":460},"filePathRelative":"jvm/02_jvm_classloader.md","localizedDate":"2024年3月11日","autoDesc":true}');export{h as comp,m as data};
