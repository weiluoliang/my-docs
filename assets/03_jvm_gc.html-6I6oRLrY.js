import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as n,c as t,b as e,d as r,e as s,a as o}from"./app-i8Ohr96Q.js";const p={},c=o('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>垃圾的定义： 不再被引用的对象就是垃圾。<br> 那如何判断一个对象是否被引用呢？</p><ul><li>引用计数法 用一个标记记录引用次数，当引用次数为0时，就是垃圾</li><li>可达性分析法 从GC Roots开始，遍历所有对象，如果对象不可达，就是垃圾。</li></ul><h2 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法"><span>垃圾回收算法</span></a></h2><ul><li>标记-清除算法<br> 先标记好回收的对象，然后统一回收</li><li>标记-压缩算法<br> 标记好回收的对象，然后将存活的对象压缩到一端，然后回收另一端的空间</li><li>复制算法<br> 将内存分为两块，每次只使用一块，当这一块满了，就将存活的对象复制到另一块，然后回收这一块</li><li>分代算法<br> 根据对象的存活周期将内存分为不同的区域，然后根据不同的区域使用不同的算法</li></ul><h2 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器"><span>垃圾回收器</span></a></h2><p>垃圾回收器是实现垃圾回收算法的具体实现，根据不同的算法和实现，可以分为以下几种 先看一张图，了解一下各个垃圾回收器的关系</p><figure><img src="https://www.luoliang.top/images/jvm_垃圾回收期.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="serial收集器" tabindex="-1"><a class="header-anchor" href="#serial收集器"><span>Serial收集器</span></a></h3><p>在新生代使用复制算法，在老年代使用标记-清除算法</p><ul><li>使用单线程进行回收</li></ul><p>优点：简单高效，没有线程切换的开销<br> 缺点：无法充分利用多核CPU</p><h3 id="parnew收集器" tabindex="-1"><a class="header-anchor" href="#parnew收集器"><span>ParNew收集器</span></a></h3><p>使用复制算法，多线程进行回收，可以和CMS收集器配合使用</p><h3 id="parallel-scavenge收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge收集器"><span>Parallel Scavenge收集器</span></a></h3><p>使用复制算法，多线程进行回收</p><h3 id="serial-old收集器" tabindex="-1"><a class="header-anchor" href="#serial-old收集器"><span>Serial Old收集器</span></a></h3><p>用于老年代的收集器，使用标记-清除算法</p><h3 id="parallel-old收集器" tabindex="-1"><a class="header-anchor" href="#parallel-old收集器"><span>Parallel Old收集器</span></a></h3><h3 id="cms收集器" tabindex="-1"><a class="header-anchor" href="#cms收集器"><span>CMS收集器</span></a></h3><p>CMS(Concurrent Mark Sweep)收集器，是一种以获取最短回收停顿时间为目标的收集器. 使用标记-清除算法，分为以下几个阶段</p><ul><li>初始标记 标记GC Roots能直接关联到的对象(STW)</li><li>并发标记 标记所有对象</li><li>重新标记 修正并发标记期间因用户程序继续运行导致标记产生变动的对象(STW)</li><li>并发清除 清除对象</li><li>并发清理 清理对象</li></ul><figure><img src="https://www.luoliang.top/images/jvm_cms垃圾回收过程.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="g1收集器" tabindex="-1"><a class="header-anchor" href="#g1收集器"><span>G1收集器</span></a></h3><p>G1 (Garbage-First)收集器，最大的特点是可以设置期望停顿时间，然后在这个时间内尽可能多的进行垃圾回收。 不再区分新生代和老年代，而是将内存分为多个区域，每个区域都可以是新生代或者老年代。</p><p>region的类型有以下几种:</p><ul><li>Eden 堆内存默认占比 5%</li><li>Survivor 新生代存货区</li><li>Old 老年代区域</li><li>Humongous 超过region50%大小的对象被确认为大对象，会被放到Humongous区域</li></ul><h4 id="垃圾回收过程" tabindex="-1"><a class="header-anchor" href="#垃圾回收过程"><span>垃圾回收过程</span></a></h4><ul><li>初始标记 标记GC Roots能直接关联到的对象(STW)</li><li>并发标记 标记所有对象</li><li>最终标记 修正并发标记期间因用户程序继续运行导致标记产生变动的对象(STW)</li><li>筛选回收 选择回收对象</li></ul><figure><img src="https://www.luoliang.top/images/jvm_g1_垃圾回收过程.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="g1收集器的优点" tabindex="-1"><a class="header-anchor" href="#g1收集器的优点"><span>G1收集器的优点</span></a></h4><ul><li>并行与并发 G1在并行处理的同时，也能与应用程序并发执行，充分利用多核CPU</li><li>分代收集 G1不再区分新生代和老年代，而是将内存分为多个区域，每个区域都可以是新生代或者老年代</li><li>空间整合 G1收集器会进行空间整合，减少内存碎片</li><li>可预测的停顿 G1可以设置期望停顿时间，然后在这个时间内尽可能多的进行垃圾回收</li></ul><h4 id="垃圾收集分类" tabindex="-1"><a class="header-anchor" href="#垃圾收集分类"><span>垃圾收集分类</span></a></h4><ul><li><p>Young GC<br> 并不是Eden区满了马上出发Young GC，而是会去计算Eden去回收大概要多久时间，如果远远小于期望停顿时间，而是增加Eden区的使用，等到下一次Eden区满了,再计算一次，如果大于期望停顿时间，就会触发Young GC。</p></li><li><p>Mixed GC 老年代的堆占有率达到设置的值(-XX:InitiatingHeapOccupancyPercent)则触发Mixed GC，回收所有的Young和部分old（根据预期停顿时间）和大对象，一般会先做mixed GC，使用复制算法进行， 把region中的存活对象复制到其他region中，然后清理掉这个region，这样可以减少碎片，如果没有足够的内存存放这些对象则会触发Full GC。</p></li><li><p>Full GC 使用单线程进行，系统会停止所有的应用线程，进行垃圾回收，这个过程会比较长，会导致系统停顿。使用标记-清除算法，然后进行空间整理。</p></li></ul><h4 id="核心参数" tabindex="-1"><a class="header-anchor" href="#核心参数"><span>核心参数</span></a></h4><ul><li>-XX:+UseG1GC:使用G1收集器</li><li>-XX:MaxGCPauseMillis 设置期望停顿时间</li><li>-XX:G1HeapRegionSize 设置region的大小</li><li>-XX:InitiatingHeapOccupancyPercent 设置老年代的堆占有率达到多少时触发Mixed GC</li><li>-XX:G1MixedGCLiveThresholdPercent 设置Mixed GC后存活对象占比多少时触发Full GC</li></ul><h3 id="zgc收集器" tabindex="-1"><a class="header-anchor" href="#zgc收集器"><span>ZGC收集器</span></a></h3><h4 id="设计目标" tabindex="-1"><a class="header-anchor" href="#设计目标"><span>设计目标</span></a></h4><ul><li>停顿时间不超过10ms</li><li>停顿时间不会随着堆内存的增加而增加</li><li>支持TB级别的堆内存（8MB~4TB）</li></ul><h3 id="shenandoah收集器" tabindex="-1"><a class="header-anchor" href="#shenandoah收集器"><span>Shenandoah收集器</span></a></h3><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2>',41),h={href:"https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html",target:"_blank",rel:"noopener noreferrer"};function d(g,m){const a=i("ExternalLinkIcon");return n(),t("div",null,[c,e("ul",null,[e("li",null,[e("a",h,[r("新一代垃圾回收器ZGC的探索与实践"),s(a)])])])])}const v=l(p,[["render",d],["__file","03_jvm_gc.html.vue"]]),E=JSON.parse('{"path":"/jvm/03_jvm_gc.html","title":"JVM的垃圾回收","lang":"zh-CN","frontmatter":{"title":"JVM的垃圾回收","icon":"fab fa-markdown","order":3,"category":["Java"],"tag":["jvm"],"editLink":false,"description":"前言 垃圾的定义： 不再被引用的对象就是垃圾。 那如何判断一个对象是否被引用呢？ 引用计数法 用一个标记记录引用次数，当引用次数为0时，就是垃圾 可达性分析法 从GC Roots开始，遍历所有对象，如果对象不可达，就是垃圾。 垃圾回收算法 标记-清除算法 先标记好回收的对象，然后统一回收 标记-压缩算法 标记好回收的对象，然后将存活的对象压缩到一端，然...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/jvm/03_jvm_gc.html"}],["meta",{"property":"og:site_name","content":"luoliang的笔记"}],["meta",{"property":"og:title","content":"JVM的垃圾回收"}],["meta",{"property":"og:description","content":"前言 垃圾的定义： 不再被引用的对象就是垃圾。 那如何判断一个对象是否被引用呢？ 引用计数法 用一个标记记录引用次数，当引用次数为0时，就是垃圾 可达性分析法 从GC Roots开始，遍历所有对象，如果对象不可达，就是垃圾。 垃圾回收算法 标记-清除算法 先标记好回收的对象，然后统一回收 标记-压缩算法 标记好回收的对象，然后将存活的对象压缩到一端，然..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.luoliang.top/images/jvm_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%9F.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-15T12:02:03.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:modified_time","content":"2024-03-15T12:02:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM的垃圾回收\\",\\"image\\":[\\"https://www.luoliang.top/images/jvm_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%9F.png\\",\\"https://www.luoliang.top/images/jvm_cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.jpeg\\",\\"https://www.luoliang.top/images/jvm_g1_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png\\"],\\"dateModified\\":\\"2024-03-15T12:02:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[]},{"level":2,"title":"垃圾回收器","slug":"垃圾回收器","link":"#垃圾回收器","children":[{"level":3,"title":"Serial收集器","slug":"serial收集器","link":"#serial收集器","children":[]},{"level":3,"title":"ParNew收集器","slug":"parnew收集器","link":"#parnew收集器","children":[]},{"level":3,"title":"Parallel Scavenge收集器","slug":"parallel-scavenge收集器","link":"#parallel-scavenge收集器","children":[]},{"level":3,"title":"Serial Old收集器","slug":"serial-old收集器","link":"#serial-old收集器","children":[]},{"level":3,"title":"Parallel Old收集器","slug":"parallel-old收集器","link":"#parallel-old收集器","children":[]},{"level":3,"title":"CMS收集器","slug":"cms收集器","link":"#cms收集器","children":[]},{"level":3,"title":"G1收集器","slug":"g1收集器","link":"#g1收集器","children":[]},{"level":3,"title":"ZGC收集器","slug":"zgc收集器","link":"#zgc收集器","children":[]},{"level":3,"title":"Shenandoah收集器","slug":"shenandoah收集器","link":"#shenandoah收集器","children":[]}]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1710297833000,"updatedTime":1710504123000,"contributors":[{"name":"William","email":"wll@example.com","commits":6}]},"readingTime":{"minutes":4.63,"words":1388},"filePathRelative":"jvm/03_jvm_gc.md","localizedDate":"2024年3月13日","autoDesc":true}');export{v as comp,E as data};
