import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as t,a as n}from"./app-BMkWD5Yq.js";const s={},l=n(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>Java是跨平台语言，看官方给的一张图，我们写的Java代码在最上层 ，最终通过Java虚拟机帮助我们去运行，根据不同操作系统翻译成不同的机器码运行，从而实现了跨平台的特性。</p><figure><img src="https://www.luoliang.top/images/jdk.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="运行时数据区" tabindex="-1"><a class="header-anchor" href="#运行时数据区"><span>运行时数据区</span></a></h2><figure><img src="https://www.luoliang.top/images/jvm_运行时数据区.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>启动java的参数示例</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>java <span class="token operator">-</span><span class="token class-name">Xms2048M</span> <span class="token operator">-</span><span class="token class-name">Xmx2048M</span> <span class="token operator">-</span><span class="token class-name">Xmn1024M</span> <span class="token operator">-</span><span class="token class-name">Xss512K</span> <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MetaspaceSize</span><span class="token operator">=</span><span class="token number">256</span>M <span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxMetaspaceSize</span><span class="token operator">=</span><span class="token number">256</span>M <span class="token operator">-</span>jar microservice<span class="token operator">-</span>eureka<span class="token operator">-</span>server<span class="token punctuation">.</span>jar 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>-Xms:初始堆大小<br> -Xmx:最大堆大小<br> -Xmn:新生代大小<br> -Xss:栈大小<br> -XX:MetaspaceSize:初始元空间大小<br> -XX:MaxMetaspaceSize:最大元空间大小</p><h3 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h3><p>堆分为新生代和老年代，新生代又分为Eden区和Survivor区，老年代是存放长期存活的对象，新生代是存放新创建的对象。</p><figure><img src="https://www.luoliang.top/images/jvm_堆结构.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区"><span>方法区</span></a></h3><p>方法区是一个抽象概念，在不同的Java版本中有不同的实现。 在JDK1.8之前，使用永久代实现，在JDK1.8之后，方法区被元空间取代。</p><p>方法区都存什么内容？</p><ul><li>类信息</li><li>静态变量</li><li>class常量池 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译期生成的各种字面量(Literal)和符号引用(Symbolic References)。</li></ul><p>我们一般可以通过javap命令生成更可读的JVM字节码指令文件：javap -v Math.class</p><figure><img src="https://www.luoliang.top/images/jvm_内存结构_反编译字节码.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈"><span>虚拟机栈</span></a></h3><p>虚拟机栈里面放的是一个个栈帧，每个栈帧对应一个方法，结构如下：</p><figure><img src="https://www.luoliang.top/images/jvm_栈帧结构.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>局部变量表 存放方法执行过程中的局部变量</li><li>操作数栈 存放方法执行过程中的临时变量，以及方法执行过程中的计算结果</li><li>动态链接 指向运行时常量池中该方法的引用</li><li>方法出口 方法执行完成后的返回地址</li></ul><h3 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h3><p>下一条指令的地址，每个线程都有一个程序计数器，不会出现内存溢出的情况。</p><h3 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈"><span>本地方法栈</span></a></h3><p>本地方法栈是为了执行本地方法服务的，与虚拟机栈类似，只不过是为本地方法服务的。</p><h2 id="字符串常量池详解" tabindex="-1"><a class="header-anchor" href="#字符串常量池详解"><span>字符串常量池详解</span></a></h2><h3 id="字符串常量池的设计思想" tabindex="-1"><a class="header-anchor" href="#字符串常量池的设计思想"><span>字符串常量池的设计思想</span></a></h3><p>字符串作为最基础的类型，会被大量的使用，如果频繁的创建字符串对象，会导致内存的浪费，所以Java设计了字符串常量池，用来存放字符串对象。</p><blockquote><p>字符串常量池是在堆内存中的，不是在方法区中的。 创建字符串对象的时候，会先去字符串常量池中查找是否有相同的字符串，如果有，就返回引用，如果没有，就创建一个新的字符串对象。</p></blockquote><p>字符串常量池位置</p><ul><li>JDK1.6 有永久代，运行时常量在永久代中，运行时常量包括字符串常量池</li><li>JDK1.7 有永久代，运行时常量在永久代中，字符串常量池从永久代中移动到堆中</li><li>JDK1.8+ 无永久代，运行时常量在元空间中，字符串常量池在堆中</li></ul><h3 id="字符串常量池的设计原理" tabindex="-1"><a class="header-anchor" href="#字符串常量池的设计原理"><span>字符串常量池的设计原理</span></a></h3>`,32),i=[l];function p(o,r){return e(),t("div",null,i)}const d=a(s,[["render",p],["__file","01_jvm_overview.html.vue"]]),h=JSON.parse('{"path":"/jvm/01_jvm_overview.html","title":"JVM的整体结构","lang":"zh-CN","frontmatter":{"title":"JVM的整体结构","icon":"fab fa-markdown","order":1,"category":["Java"],"tag":["jvm"],"editLink":false,"description":"前言 Java是跨平台语言，看官方给的一张图，我们写的Java代码在最上层 ，最终通过Java虚拟机帮助我们去运行，根据不同操作系统翻译成不同的机器码运行，从而实现了跨平台的特性。 运行时数据区 启动java的参数示例 -Xms:初始堆大小 -Xmx:最大堆大小 -Xmn:新生代大小 -Xss:栈大小 -XX:MetaspaceSize:初始元空间大小...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/jvm/01_jvm_overview.html"}],["meta",{"property":"og:site_name","content":"luoliang的笔记"}],["meta",{"property":"og:title","content":"JVM的整体结构"}],["meta",{"property":"og:description","content":"前言 Java是跨平台语言，看官方给的一张图，我们写的Java代码在最上层 ，最终通过Java虚拟机帮助我们去运行，根据不同操作系统翻译成不同的机器码运行，从而实现了跨平台的特性。 运行时数据区 启动java的参数示例 -Xms:初始堆大小 -Xmx:最大堆大小 -Xmn:新生代大小 -Xss:栈大小 -XX:MetaspaceSize:初始元空间大小..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.luoliang.top/images/jdk.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-11T14:49:13.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:modified_time","content":"2024-03-11T14:49:13.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM的整体结构\\",\\"image\\":[\\"https://www.luoliang.top/images/jdk.png\\",\\"https://www.luoliang.top/images/jvm_%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png\\",\\"https://www.luoliang.top/images/jvm_%E5%A0%86%E7%BB%93%E6%9E%84.png\\",\\"https://www.luoliang.top/images/jvm_%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84_%E5%8F%8D%E7%BC%96%E8%AF%91%E5%AD%97%E8%8A%82%E7%A0%81.png\\",\\"https://www.luoliang.top/images/jvm_%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84.png\\"],\\"dateModified\\":\\"2024-03-11T14:49:13.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"运行时数据区","slug":"运行时数据区","link":"#运行时数据区","children":[{"level":3,"title":"堆","slug":"堆","link":"#堆","children":[]},{"level":3,"title":"方法区","slug":"方法区","link":"#方法区","children":[]},{"level":3,"title":"虚拟机栈","slug":"虚拟机栈","link":"#虚拟机栈","children":[]},{"level":3,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[]},{"level":3,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]}]},{"level":2,"title":"字符串常量池详解","slug":"字符串常量池详解","link":"#字符串常量池详解","children":[{"level":3,"title":"字符串常量池的设计思想","slug":"字符串常量池的设计思想","link":"#字符串常量池的设计思想","children":[]},{"level":3,"title":"字符串常量池的设计原理","slug":"字符串常量池的设计原理","link":"#字符串常量池的设计原理","children":[]}]}],"git":{"createdTime":1710148641000,"updatedTime":1710168553000,"contributors":[{"name":"William","email":"wll@example.com","commits":2},{"name":"william","email":"625753396@qq.com","commits":1}]},"readingTime":{"minutes":3,"words":900},"filePathRelative":"jvm/01_jvm_overview.md","localizedDate":"2024年3月11日","autoDesc":true}');export{d as comp,h as data};
