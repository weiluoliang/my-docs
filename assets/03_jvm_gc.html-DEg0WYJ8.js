import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as l,a as t}from"./app-BMkWD5Yq.js";const i={},n=t('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>垃圾的定义： 不再被引用的对象就是垃圾。<br> 那如何判断一个对象是否被引用呢？</p><ul><li>引用计数法 用一个标记记录引用次数，当引用次数为0时，就是垃圾</li><li>可达性分析法 从GC Roots开始，遍历所有对象，如果对象不可达，就是垃圾。</li></ul><h2 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法"><span>垃圾回收算法</span></a></h2><ul><li>标记-清除算法<br> 先标记好回收的对象，然后统一回收</li><li>标记-压缩算法<br> 标记好回收的对象，然后将存活的对象压缩到一端，然后回收另一端的空间</li><li>复制算法<br> 将内存分为两块，每次只使用一块，当这一块满了，就将存活的对象复制到另一块，然后回收这一块</li><li>分代算法<br> 根据对象的存活周期将内存分为不同的区域，然后根据不同的区域使用不同的算法</li></ul><h2 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器"><span>垃圾回收器</span></a></h2><p>垃圾回收器是实现垃圾回收算法的具体实现，根据不同的算法和实现，可以分为以下几种 先看一张图，了解一下各个垃圾回收器的关系</p><figure><img src="https://www.luoliang.top/images/jvm_垃圾回收期.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="serial收集器" tabindex="-1"><a class="header-anchor" href="#serial收集器"><span>Serial收集器</span></a></h3><p>在新生代使用复制算法，在老年代使用标记-清除算法</p><ul><li>使用单线程进行回收</li></ul><p>优点：简单高效，没有线程切换的开销<br> 缺点：无法充分利用多核CPU</p><h3 id="parnew收集器" tabindex="-1"><a class="header-anchor" href="#parnew收集器"><span>ParNew收集器</span></a></h3><p>使用复制算法，多线程进行回收，可以和CMS收集器配合使用</p><h3 id="parallel-scavenge收集器" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge收集器"><span>Parallel Scavenge收集器</span></a></h3><p>使用复制算法，多线程进行回收</p><h3 id="serial-old收集器" tabindex="-1"><a class="header-anchor" href="#serial-old收集器"><span>Serial Old收集器</span></a></h3><p>用于老年代的收集器，使用标记-清除算法</p><h3 id="parallel-old收集器" tabindex="-1"><a class="header-anchor" href="#parallel-old收集器"><span>Parallel Old收集器</span></a></h3><h3 id="cms收集器" tabindex="-1"><a class="header-anchor" href="#cms收集器"><span>CMS收集器</span></a></h3><p>CMS(Concurrent Mark Sweep)收集器，是一种以获取最短回收停顿时间为目标的收集器. 使用标记-清除算法，分为以下几个阶段</p><ul><li>初始标记 标记GC Roots能直接关联到的对象(STW)</li><li>并发标记 标记所有对象</li><li>重新标记 修正并发标记期间因用户程序继续运行导致标记产生变动的对象(STW)</li><li>并发清除 清除对象</li><li>并发清理 清理对象</li></ul><figure><img src="https://www.luoliang.top/images/jvm_cms垃圾回收过程.jpeg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="g1收集器" tabindex="-1"><a class="header-anchor" href="#g1收集器"><span>G1收集器</span></a></h3><p>G1 (Garbage-First)收集器，最大的特点是可以设置期望停顿时间，然后在这个时间内尽可能多的进行垃圾回收。 不再区分新生代和老年代，而是将内存分为多个区域，每个区域都可以是新生代或者老年代。</p><h3 id="zgc收集器" tabindex="-1"><a class="header-anchor" href="#zgc收集器"><span>ZGC收集器</span></a></h3><h3 id="shenandoah收集器" tabindex="-1"><a class="header-anchor" href="#shenandoah收集器"><span>Shenandoah收集器</span></a></h3>',27),r=[n];function s(o,p){return a(),l("div",null,r)}const d=e(i,[["render",s],["__file","03_jvm_gc.html.vue"]]),g=JSON.parse('{"path":"/jvm/03_jvm_gc.html","title":"JVM的垃圾回收","lang":"zh-CN","frontmatter":{"title":"JVM的垃圾回收","icon":"fab fa-markdown","order":3,"category":["Java"],"tag":["jvm"],"editLink":false,"description":"前言 垃圾的定义： 不再被引用的对象就是垃圾。 那如何判断一个对象是否被引用呢？ 引用计数法 用一个标记记录引用次数，当引用次数为0时，就是垃圾 可达性分析法 从GC Roots开始，遍历所有对象，如果对象不可达，就是垃圾。 垃圾回收算法 标记-清除算法 先标记好回收的对象，然后统一回收 标记-压缩算法 标记好回收的对象，然后将存活的对象压缩到一端，然...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/jvm/03_jvm_gc.html"}],["meta",{"property":"og:site_name","content":"luoliang的笔记"}],["meta",{"property":"og:title","content":"JVM的垃圾回收"}],["meta",{"property":"og:description","content":"前言 垃圾的定义： 不再被引用的对象就是垃圾。 那如何判断一个对象是否被引用呢？ 引用计数法 用一个标记记录引用次数，当引用次数为0时，就是垃圾 可达性分析法 从GC Roots开始，遍历所有对象，如果对象不可达，就是垃圾。 垃圾回收算法 标记-清除算法 先标记好回收的对象，然后统一回收 标记-压缩算法 标记好回收的对象，然后将存活的对象压缩到一端，然..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://www.luoliang.top/images/jvm_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%9F.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-14T12:16:09.000Z"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["meta",{"property":"article:tag","content":"jvm"}],["meta",{"property":"article:modified_time","content":"2024-03-14T12:16:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM的垃圾回收\\",\\"image\\":[\\"https://www.luoliang.top/images/jvm_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%9F.png\\",\\"https://www.luoliang.top/images/jvm_cms%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.jpeg\\"],\\"dateModified\\":\\"2024-03-14T12:16:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[]},{"level":2,"title":"垃圾回收器","slug":"垃圾回收器","link":"#垃圾回收器","children":[{"level":3,"title":"Serial收集器","slug":"serial收集器","link":"#serial收集器","children":[]},{"level":3,"title":"ParNew收集器","slug":"parnew收集器","link":"#parnew收集器","children":[]},{"level":3,"title":"Parallel Scavenge收集器","slug":"parallel-scavenge收集器","link":"#parallel-scavenge收集器","children":[]},{"level":3,"title":"Serial Old收集器","slug":"serial-old收集器","link":"#serial-old收集器","children":[]},{"level":3,"title":"Parallel Old收集器","slug":"parallel-old收集器","link":"#parallel-old收集器","children":[]},{"level":3,"title":"CMS收集器","slug":"cms收集器","link":"#cms收集器","children":[]},{"level":3,"title":"G1收集器","slug":"g1收集器","link":"#g1收集器","children":[]},{"level":3,"title":"ZGC收集器","slug":"zgc收集器","link":"#zgc收集器","children":[]},{"level":3,"title":"Shenandoah收集器","slug":"shenandoah收集器","link":"#shenandoah收集器","children":[]}]}],"git":{"createdTime":1710297833000,"updatedTime":1710418569000,"contributors":[{"name":"William","email":"wll@example.com","commits":3}]},"readingTime":{"minutes":2.35,"words":705},"filePathRelative":"jvm/03_jvm_gc.md","localizedDate":"2024年3月13日","autoDesc":true}');export{d as comp,g as data};
